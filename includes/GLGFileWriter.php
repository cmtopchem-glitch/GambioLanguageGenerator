<?php
/**
 * Gambio Language Generator - File Writer
 * 
 * Schreibt übersetzte Sprachdaten in die entsprechenden PHP-Dateien
 * 
 * @author Christian Mittenzwei
 * @version 1.0.0
 */

class GLGFileWriter {
    
    private $backupEnabled;
    private $backupPath;
    
    public function __construct($backupEnabled = true) {
        $this->backupEnabled = $backupEnabled;
        $this->backupPath = DIR_FS_CATALOG . 'backup/language_generator/';
        
        if ($this->backupEnabled && !is_dir($this->backupPath)) {
            mkdir($this->backupPath, 0755, true);
        }
    }
    
    /**
     * Schreibt Sprachdateien für eine komplette Source
     * 
     * @param array $sourceData Daten aus GLGReader
     * @param string $targetLanguage Zielsprache
     * @return array Ergebnis mit Statistiken
     */
    public function writeSourceFile($sourceData, $targetLanguage) {
        $source = $sourceData['source'];
        $sections = $sourceData['sections'];
        
        // Bestimme Dateipfad
        $targetFile = $this->getTargetFilePath($source, $targetLanguage);
        
        // Erstelle Backup wenn aktiviert
        if ($this->backupEnabled && file_exists($targetFile)) {
            $this->createBackup($targetFile);
        }
        
        // Erstelle Verzeichnis wenn nicht vorhanden
        $targetDir = dirname($targetFile);
        if (!is_dir($targetDir)) {
            mkdir($targetDir, 0755, true);
        }
        
        // Prüfe ob es eine GXModule-Datei ist
        if (strpos($source, 'GXModules/') === 0) {
            return $this->writeGXModuleFile($targetFile, $sections);
        } else {
            return $this->writeCoreFile($targetFile, $sections);
        }
    }
    
    /**
     * Schreibt eine Core-Sprachdatei
     */
    private function writeCoreFile($targetFile, $sections) {
        $content = "<?php\n";
        $content .= "/**\n";
        $content .= " * Gambio Language File\n";
        $content .= " * \n";
        $content .= " * Generated by Gambio Language Generator\n";
        $content .= " * @date " . date('Y-m-d H:i:s') . "\n";
        $content .= " */\n\n";
        
        // Core-Dateien haben meist nur eine Sektion oder keine
        if (count($sections) === 1 && isset($sections[''])) {
            // Keine Sektion
            $content .= $this->formatArray($sections[''], '$t_language_text_section_content_array');
        } else {
            // Mehrere Sektionen
            $content .= "\$t_language_text_section_content_array = array(\n";
            
            foreach ($sections as $sectionName => $entries) {
                if (empty($sectionName)) {
                    // Root-Level Einträge
                    foreach ($entries as $key => $value) {
                        $content .= $this->formatEntry($key, $value, 1);
                    }
                } else {
                    // Verschachtelte Sektion
                    $content .= "\t'" . addslashes($sectionName) . "' => array(\n";
                    foreach ($entries as $key => $value) {
                        $content .= $this->formatEntry($key, $value, 2);
                    }
                    $content .= "\t),\n";
                }
            }
            
            $content .= ");\n";
        }
        
        return $this->writeFile($targetFile, $content);
    }
    
    /**
     * Schreibt eine GXModule-Sprachdatei
     */
    private function writeGXModuleFile($targetFile, $sections) {
        $content = "<?php\n";
        $content .= "/**\n";
        $content .= " * GXModule Language File\n";
        $content .= " * \n";
        $content .= " * Generated by Gambio Language Generator\n";
        $content .= " * @date " . date('Y-m-d H:i:s') . "\n";
        $content .= " */\n\n";
        
        // GXModule-Dateien verwenden verschachtelte Arrays
        $content .= "\$t_language_text_section_content_array = array(\n";
        
        foreach ($sections as $sectionName => $entries) {
            if (empty($sectionName)) {
                // Root-Level Einträge
                foreach ($entries as $key => $value) {
                    $content .= $this->formatEntry($key, $value, 1);
                }
            } else {
                // Verschachtelte Sektion
                $content .= "\t'" . addslashes($sectionName) . "' => array(\n";
                foreach ($entries as $key => $value) {
                    $content .= $this->formatEntry($key, $value, 2);
                }
                $content .= "\t),\n";
            }
        }
        
        $content .= ");\n";
        
        return $this->writeFile($targetFile, $content);
    }
    
    /**
     * Formatiert ein Array als PHP Code
     */
    private function formatArray($entries, $varName) {
        $content = "$varName = array(\n";
        
        foreach ($entries as $key => $value) {
            $content .= $this->formatEntry($key, $value, 1);
        }
        
        $content .= ");\n";
        
        return $content;
    }
    
    /**
     * Formatiert einen einzelnen Eintrag
     */
    private function formatEntry($key, $value, $indentLevel = 1) {
        $indent = str_repeat("\t", $indentLevel);
        $escapedKey = addslashes($key);
        $escapedValue = addslashes($value);
        
        return "$indent'$escapedKey' => '$escapedValue',\n";
    }
    
    /**
     * Bestimmt den Ziel-Dateipfad
     */
    private function getTargetFilePath($source, $targetLanguage) {
        // Ersetze die Sprache im Pfad
        // z.B. "lang/german/buttons.php" -> "lang/english/buttons.php"
        // oder "GXModules/MyModule/lang/german/admin.php" -> "GXModules/MyModule/lang/english/admin.php"
        
        if (preg_match('#/lang/[^/]+/#', $source)) {
            // Hat bereits /lang/sprache/ im Pfad
            $targetPath = preg_replace('#/lang/[^/]+/#', '/lang/' . $targetLanguage . '/', $source);
        } else {
            // Fallback: Ersetze ersten Sprachnamen
            $languages = $this->getAvailableLanguages();
            foreach ($languages as $lang) {
                if (strpos($source, $lang) !== false) {
                    $targetPath = str_replace($lang, $targetLanguage, $source);
                    break;
                }
            }
            
            if (!isset($targetPath)) {
                throw new Exception('Konnte Zielsprache nicht im Pfad ersetzen: ' . $source);
            }
        }
        
        return DIR_FS_CATALOG . $targetPath;
    }
    
    /**
     * Gibt verfügbare Sprachen zurück
     */
    private function getAvailableLanguages() {
        $query = "SELECT directory FROM languages";
        $result = xtc_db_query($query);
        
        $languages = [];
        while ($row = xtc_db_fetch_array($result)) {
            $languages[] = $row['directory'];
        }
        
        return $languages;
    }
    
    /**
     * Schreibt Inhalt in Datei
     */
    private function writeFile($targetFile, $content) {
        $success = file_put_contents($targetFile, $content);
        
        if ($success === false) {
            throw new Exception('Konnte Datei nicht schreiben: ' . $targetFile);
        }
        
        // Setze Berechtigungen
        chmod($targetFile, 0644);
        
        return [
            'success' => true,
            'file' => $targetFile,
            'bytes' => $success
        ];
    }
    
    /**
     * Erstellt Backup einer Datei
     */
    private function createBackup($sourceFile) {
        $timestamp = date('Y-m-d_His');
        $relativePath = str_replace(DIR_FS_CATALOG, '', $sourceFile);
        $backupFile = $this->backupPath . $timestamp . '/' . $relativePath;
        
        $backupDir = dirname($backupFile);
        if (!is_dir($backupDir)) {
            mkdir($backupDir, 0755, true);
        }
        
        return copy($sourceFile, $backupFile);
    }
    
    /**
     * Bereinigt alte Backups (älter als X Tage)
     */
    public function cleanupOldBackups($days = 30) {
        if (!is_dir($this->backupPath)) {
            return;
        }
        
        $threshold = time() - ($days * 86400);
        $dirs = scandir($this->backupPath);
        
        foreach ($dirs as $dir) {
            if ($dir === '.' || $dir === '..') {
                continue;
            }
            
            $dirPath = $this->backupPath . $dir;
            if (!is_dir($dirPath)) {
                continue;
            }
            
            if (filemtime($dirPath) < $threshold) {
                $this->deleteDirectory($dirPath);
            }
        }
    }
    
    /**
     * Löscht Verzeichnis rekursiv
     */
    private function deleteDirectory($dir) {
        if (!is_dir($dir)) {
            return;
        }
        
        $files = array_diff(scandir($dir), ['.', '..']);
        
        foreach ($files as $file) {
            $path = $dir . '/' . $file;
            is_dir($path) ? $this->deleteDirectory($path) : unlink($path);
        }
        
        return rmdir($dir);
    }
    
    /**
     * Validiert eine Sprachdatei
     */
    public function validateFile($file) {
        if (!file_exists($file)) {
            return [
                'valid' => false,
                'error' => 'Datei existiert nicht'
            ];
        }
        
        // Syntax-Check
        $output = [];
        $returnCode = 0;
        exec('php -l ' . escapeshellarg($file) . ' 2>&1', $output, $returnCode);
        
        if ($returnCode !== 0) {
            return [
                'valid' => false,
                'error' => 'Syntax-Fehler: ' . implode("\n", $output)
            ];
        }
        
        return [
            'valid' => true,
            'error' => null
        ];
    }
    
    /**
     * Gibt Statistiken über geschriebene Dateien zurück
     */
    public function getWriteStatistics($results) {
        $stats = [
            'total_files' => count($results),
            'success' => 0,
            'failed' => 0,
            'total_bytes' => 0
        ];
        
        foreach ($results as $result) {
            if ($result['success']) {
                $stats['success']++;
                $stats['total_bytes'] += $result['bytes'];
            } else {
                $stats['failed']++;
            }
        }
        
        return $stats;
    }
}
